<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>immortal</title>
    <link>https://immortal.run/index.xml</link>
    <description>Recent content on immortal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright> </copyright>
    <lastBuildDate>Tue, 21 Mar 2017 12:04:36 +0100</lastBuildDate>
    <atom:link href="https://immortal.run/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How it works</title>
      <link>https://immortal.run/post/how-it-works/</link>
      <pubDate>Tue, 21 Mar 2017 12:04:36 +0100</pubDate>
      
      <guid>https://immortal.run/post/how-it-works/</guid>
      <description>

&lt;p&gt;⭕  immortal runs a command or script detached from the controlling terminal
as a Unix daemon, it will supervise and restart the service if it has
been terminated. The service can be controlled by querying a Unix socket
&amp;ldquo;immortal.sock&amp;rdquo;, this allows to remotely have full control over the service if
required by exposing the socket using a web server like Nginx.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;immortal    - Starts and monitor a service
immortaldir - Directory to scan for services *.yml
immortalctl - Control existing services
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;immortal&#34;&gt;immortal&lt;/h1&gt;

&lt;p&gt;To start an keep runing forever&lt;/p&gt;

&lt;h1 id=&#34;immortaldir&#34;&gt;immortaldir&lt;/h1&gt;

&lt;h1 id=&#34;immortalctl&#34;&gt;immortalctl&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>pkg install immortal</title>
      <link>https://immortal.run/freebsd/</link>
      <pubDate>Mon, 20 Mar 2017 16:17:00 +0000</pubDate>
      
      <guid>https://immortal.run/freebsd/</guid>
      <description>&lt;p&gt;To install &lt;strong&gt;immortal&lt;/strong&gt; on  FreeBSD:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pkg install immortal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.freshports.org/sysutils/immortal&#34;&gt;https://www.freshports.org/sysutils/immortal&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>homebrew</title>
      <link>https://immortal.run/mac/</link>
      <pubDate>Thu, 16 Mar 2017 22:54:37 +0100</pubDate>
      
      <guid>https://immortal.run/mac/</guid>
      <description>&lt;p&gt;To install &lt;strong&gt;immortal&lt;/strong&gt; on Mac OS X:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew tap immortal/tap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install immortal
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>The problem to solve</title>
      <link>https://immortal.run/post/the-problem-to-solve/</link>
      <pubDate>Wed, 20 Jul 2016 21:07:15 +0200</pubDate>
      
      <guid>https://immortal.run/post/the-problem-to-solve/</guid>
      <description>

&lt;h2 id=&#34;a-common-way-to-start-up-services&#34;&gt;A common way to start up services&lt;/h2&gt;

&lt;p&gt;Either you are using macOs, FreeBSD, or any Linux variant the idea is to
simplify how process/services are keep up and running, without need to worry
about special environments or paths.&lt;/p&gt;

&lt;p&gt;A single &lt;a href=&#34;https://immortal.run/post/run.yml&#34;&gt;&lt;code&gt;run.yml&lt;/code&gt;&lt;/a&gt; file should be enough for start and supervise
the services, or used as a template within automation tools like
&lt;a href=&#34;http://saltstack.org&#34;&gt;Saltstack&lt;/a&gt;, &lt;a href=&#34;https://ansible.com&#34;&gt;Ansible&lt;/a&gt;, etc.&lt;/p&gt;

&lt;h2 id=&#34;follow-pid&#34;&gt;Follow PID&lt;/h2&gt;

&lt;p&gt;In some cases it is required to supervise applications that
daemonize by default. Normally this kind of applications create a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Process_identifier#Pidfile&#34;&gt;pidfile&lt;/a&gt; every time
they &lt;a href=&#34;https://en.wikipedia.org/wiki/Fork_(system_call)&#34;&gt;fork&lt;/a&gt;, the one can be
used to follow subsequent forks and avoid creating a race condition between
the supervisor trying to start again the process and the forks created by the
application.&lt;/p&gt;

&lt;p&gt;Example of a race condition while trying to supervise unicorn with runit:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/80371.js&#34; id=&#34;asciicast-80371&#34; async&gt;&lt;/script&gt;
&lt;/div&gt;


&lt;p&gt;In the example given below, after forking (&lt;code&gt;kill -USR2 $PID&lt;/code&gt;), The supervisor in use
&lt;code&gt;runit&lt;/code&gt; in this case, tries to start up again the application, since the
process that was supervising died, but instead enters into loop
because the application still up and running using the same port.&lt;/p&gt;

&lt;h2 id=&#34;logging&#34;&gt;logging&lt;/h2&gt;

&lt;p&gt;When working in distributed &amp;ldquo;cloud&amp;rdquo; environments, centralized logging becomes a
requirement, therefore it is desired to have availability to chose how and where
to log, either to a local file, to a local file and to a remote server or only
remotely either TCP or UDP.&lt;/p&gt;

&lt;p&gt;To achive this, &lt;strong&gt;immortal&lt;/strong&gt; is not only capable to write logs to a defined
file, but is also allows to specify an external logger, by specifying the &lt;code&gt;-l&lt;/code&gt;
and &lt;code&gt;-logger&lt;/code&gt; options example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ immortal -l /tmp/test.log -logger &amp;quot;logger -t test&amp;quot; my-app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case &lt;code&gt;-loger&lt;/code&gt; is going to pass the Stander output/error to the
&lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?logger(1)&#34;&gt;logger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Example logging to a file and to the system syslog using &lt;code&gt;logger&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/80376.js&#34; id=&#34;asciicast-80376&#34; async&gt;&lt;/script&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>⭕  immortal</title>
      <link>https://immortal.run/about/</link>
      <pubDate>Wed, 20 Jul 2016 17:34:22 +0200</pubDate>
      
      <guid>https://immortal.run/about/</guid>
      <description>

&lt;h1 id=&#34;what-is-immortal&#34;&gt;What is immortal ?&lt;/h1&gt;

&lt;p&gt;A *nix cross-platform (OS agnostic) supervisor based on
&lt;a href=&#34;https://cr.yp.to/daemontools.html&#34;&gt;daemontools&lt;/a&gt; &amp;amp; &lt;a href=&#34;http://smarden.org/runit/&#34;&gt;runit&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Improve the wheel, don’t reinvent it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;why-another-supervisor&#34;&gt;Why another supervisor ?&lt;/h1&gt;

&lt;p&gt;Daemontools &amp;amp; runit work very well but don&amp;rsquo;t cover all use cases, mainly when
dealing with applications that follow the zero-downtime deployment pattern
(&lt;a href=&#34;https://unicorn.bogomips.org/&#34;&gt;unicorn&lt;/a&gt;/&lt;a href=&#34;http://gunicorn.org/&#34;&gt;gunicorn&lt;/a&gt;),
applications that daemonize itself like &lt;a href=&#34;http://nginx.org&#34;&gt;nginx&lt;/a&gt; or when
distributed logging is required.&lt;/p&gt;

&lt;p&gt;Example of a zero-downtime flow using unicorn and signal handling:
&lt;a href=&#34;https://asciinema.org/a/80357&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/80357.png&#34; alt=&#34;asciicast&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;⭕  immortal, follows and implements the same logic/principles of daemontools, it
only extends some features to cover more needs, like the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-f follow pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because of this, it aims to be compatible with existing daemontools or runit
&lt;a href=&#34;https://cr.yp.to/daemontools/supervise.html&#34;&gt;run&lt;/a&gt; scripts.&lt;/p&gt;

&lt;p&gt;Example using the &lt;code&gt;-f follow pid&lt;/code&gt; option supervising unicorn:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/108148&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/108148.png&#34; alt=&#34;asciicast&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When working in distributed &amp;ldquo;cloud&amp;rdquo; environments or while doing Continuous
Deployments, exists the need to automate the behavior of the supervisor on
demand, because of this &lt;strong&gt;immortal&lt;/strong&gt; can be used with a custom configuration
file &lt;code&gt;run.yml&lt;/code&gt; helping to simplify the deployment flow besides
offering more flexibility.&lt;/p&gt;

&lt;p&gt;Example &lt;code&gt;run.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmd: bundle exec unicorn -c unicorn.rb
cwd: /arena/app-1/tmp
env:
    DEBUG: 1
    ENVIRONMENT: production
pid:
    follow: /arena/app-1/unicorn.pid
    parent: /arena/app-1/parent.pid
    child: /arena/app-1/child.pid
log:
    file: /var/log/app-1.log
    age: 86400 # seconds
    num: 7     # int
    size: 1    # MegaBytes
logger: filebeat -c filebeat.yml -v -once
user: www
wait: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;manage-your-process-using-a-json-api&#34;&gt;Manage your process using a JSON API&lt;/h1&gt;

&lt;p&gt;⭕ &lt;strong&gt;immortal&lt;/strong&gt; exposes full control over the process via an Unix socket,
returning status in JSON format allowing with this to query and full manage the
process via http, based on the requirements the services could be exposed via
any web server like Nginx.&lt;/p&gt;

&lt;p&gt;Example using curl to query the status of a process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl --unix-socket immortal.sock http:/status -s | jq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outputs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;pid&amp;quot;: 6940,
  &amp;quot;up&amp;quot;: &amp;quot;7.9s&amp;quot;,
  &amp;quot;cmd&amp;quot;: &amp;quot;./stdout&amp;quot;,
  &amp;quot;fpid&amp;quot;: false,
  &amp;quot;count&amp;quot;: 4
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>run.yml</title>
      <link>https://immortal.run/post/run.yml/</link>
      <pubDate>Wed, 06 Jul 2016 20:35:39 +0200</pubDate>
      
      <guid>https://immortal.run/post/run.yml/</guid>
      <description>

&lt;h2 id=&#34;immortal-c-run-yml&#34;&gt;immortal -c run.yml&lt;/h2&gt;

&lt;p&gt;A configuration file for running/logging/supervising:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmd: bundle exec unicorn -c unicorn.rb
cwd: /arena/app-1
env:
    DEBUG: 1
    ENVIRONMENT: production
pid:
    follow: /arena/app-1/unicorn.pid
    parent: /arena/app-1/parent.pid
    child: /arena/app-1/child.pid
log:
    file: /var/log/app-1.log
    age: 86400 # seconds
    num: 7     # int
    size: 1    # MegaBytes
logger: logger -t unicorn
user: www
wait: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the main ideas behind the &lt;code&gt;run.yml&lt;/code&gt; is to eliminate an
operations/devops dependency while deploying.&lt;/p&gt;

&lt;p&gt;The application &amp;ldquo;micro service&amp;rdquo; can be shipped with a &lt;code&gt;run.yml&lt;/code&gt; and when
doing a CI &amp;amp; CD flow, by simple updating the &lt;code&gt;run.yml&lt;/code&gt; file, the &lt;strong&gt;immortal&lt;/strong&gt;
supervisor could stop, restart, pause, resume the service without need to
logging the server and execute does steps.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>