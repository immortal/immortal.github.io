<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on immortal</title>
    <link>https://immortal.run/post/</link>
    <description>Recent content in Posts on immortal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright> </copyright>
    <lastBuildDate>Tue, 21 Mar 2017 12:04:36 +0100</lastBuildDate>
    
	<atom:link href="https://immortal.run/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How it works</title>
      <link>https://immortal.run/post/how-it-works/</link>
      <pubDate>Tue, 21 Mar 2017 12:04:36 +0100</pubDate>
      
      <guid>https://immortal.run/post/how-it-works/</guid>
      <description>⭕ immortal runs a command or script detached from the controlling terminal as a Unix daemon, it will supervise and restart the service if it has been terminated. The service can be controlled by querying a Unix socket &amp;ldquo;immortal.sock&amp;rdquo; (immortalctl), this allows to remotely have full control over the service if required by exposing the socket using a web server like Nginx.
immortal - Starts and monitor a service immortaldir - Directory to scan for services *.</description>
    </item>
    
    <item>
      <title>The problem to solve</title>
      <link>https://immortal.run/post/the-problem-to-solve/</link>
      <pubDate>Wed, 20 Jul 2016 21:07:15 +0200</pubDate>
      
      <guid>https://immortal.run/post/the-problem-to-solve/</guid>
      <description>A common way to start up services Either you are using macOs, FreeBSD, or any Linux variant the idea is to simplify how process/services are keep up and running, without need to worry about special environments or paths.
A single run.yml file should be enough for start and supervise the services, or used as a template within automation tools like Saltstack, Ansible, etc.
Follow PID In some cases it is required to supervise applications that daemonize by default.</description>
    </item>
    
    <item>
      <title>run.yml</title>
      <link>https://immortal.run/post/run.yml/</link>
      <pubDate>Wed, 06 Jul 2016 20:35:39 +0200</pubDate>
      
      <guid>https://immortal.run/post/run.yml/</guid>
      <description>immortal -c run.yml A configuration file for running/logging/supervising:
cmd: bundle exec unicorn -c unicorn.rb cwd: /arena/app-1 env: DEBUG: 1 ENVIRONMENT: production pid: follow: /arena/app-1/unicorn.pid parent: /arena/app-1/parent.pid child: /arena/app-1/child.pid log: file: /var/log/app-1.log age: 86400 # seconds num: 7 # int size: 1 # MegaBytes logger: logger -t unicorn user: www wait: 1 require: - foo - bar  One of the main ideas behind the run.yml is to eliminate an operations/devops dependency while deploying.</description>
    </item>
    
    <item>
      <title>Using Nginx</title>
      <link>https://immortal.run/post/nginx/</link>
      <pubDate>Fri, 26 Mar 2010 23:14:08 +0200</pubDate>
      
      <guid>https://immortal.run/post/nginx/</guid>
      <description>To expose the services via web Nginx can be used.
Configuration example:
upstream immortal { server unix:/var/run/immortal/sleep/immortal.sock; } server { listen 80 default_server; server_name _; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; # for keep-alive proxy_pass http://immortal/; proxy_redirect off; } }  Based on the setup, permissions for the socket may need to be changed:
$ chmod 766 /var/run/immortal/&amp;lt;service name&amp;gt;/immortal.sock  To check the service status:</description>
    </item>
    
    <item>
      <title>Ansible</title>
      <link>https://immortal.run/post/ansible/</link>
      <pubDate>Fri, 26 Mar 2010 23:10:08 +0200</pubDate>
      
      <guid>https://immortal.run/post/ansible/</guid>
      <description>Example of a basic ansible playbook for deploying a micro service using a configuration file:
- hosts: your-host become: true tasks: - name: create arena file: path=/arena/foo/releases state=directory - name: set now variable set_fact: now: &amp;quot;{{ ansible_date_time.iso8601 }}&amp;quot; - name: create arena release dir file: path=/arena/foo/releases/{{ now }} state=directory - name: download app.bz2 get_url: url: &amp;quot;http://domain.tld/foo/{{ &#39;freebsd&#39; if ansible_os_family == &#39;FreeBSD&#39; else &#39;linux&#39; }}/app.tar.bz2&amp;quot; dest: /arena/foo/releases/{{ now }} - name: unarchive app.</description>
    </item>
    
    <item>
      <title>immortal</title>
      <link>https://immortal.run/post/immortal/</link>
      <pubDate>Thu, 25 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortal/</guid>
      <description>⭕ immortal runs a command or script detached from the controlling terminal as a Unix daemon, it will supervise and restart the service if it has been terminated. The service can be controlled by querying a Unix socket &amp;ldquo;immortal.sock&amp;rdquo;, this allows to remotely have full control over the service if required by exposing the socket using a web server like Nginx.
immortal [-v] [-ctl dir] [-d dir] [-e dir] [-f pidfile] [-l logfile] [-logger logger] [-p child_pidfile] [-P supervisor_pidfile] [-u user] command  -d dir Change to directory &amp;lt;dir&amp;gt; before starting the command</description>
    </item>
    
    <item>
      <title>immortalctl</title>
      <link>https://immortal.run/post/immortalctl/</link>
      <pubDate>Wed, 24 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortalctl/</guid>
      <description>immortalctl control services started by immortal
immortalctl [options] [-12achikinouqstvw] [*|service]  immortalctl by default prints the status of any available processes started by immortal, it first searches for user process located in $HOME/.immortal and next on the system global services started by immortaldir located by default in /var/run/immortal unless this has been changed by defining the environment var IMMORTAL_SDIR.
When no services found the output will be a single row only with the headers:</description>
    </item>
    
    <item>
      <title>immortaldir</title>
      <link>https://immortal.run/post/immortaldir/</link>
      <pubDate>Tue, 23 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortaldir/</guid>
      <description>immortaldir start services located in a specified directory.
immortalctl [dir] [-v]  immortaldir will scan every 5 seconds a directory searching for files ending in .yml and track changes. The files should conform the immortal configuration format.
If a file changes the service will be restarted, immortalctl exit &amp;amp; stop.
If a file is touched and service is down, it will be started, immortalctl start.
If a file is removed, the supervisor will exit, immortalctl exit, this may end the existing process but in cases where the PID is been followed, only the supervisor will exit.</description>
    </item>
    
  </channel>
</rss>