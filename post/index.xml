<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on immortal</title>
    <link>https://immortal.run/post/index.xml</link>
    <description>Recent content in Posts on immortal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright> </copyright>
    <lastBuildDate>Tue, 21 Mar 2017 12:04:36 +0100</lastBuildDate>
    <atom:link href="https://immortal.run/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How it works</title>
      <link>https://immortal.run/post/how-it-works/</link>
      <pubDate>Tue, 21 Mar 2017 12:04:36 +0100</pubDate>
      
      <guid>https://immortal.run/post/how-it-works/</guid>
      <description>&lt;p&gt;⭕  &lt;code&gt;immortal&lt;/code&gt; runs a command or script detached from the controlling terminal
as a Unix daemon, it will supervise and restart the service if it has
been terminated. The service can be controlled by querying a Unix socket
&amp;ldquo;immortal.sock&amp;rdquo; (&lt;code&gt;immortalctl&lt;/code&gt;), this allows to remotely have full control over
the service if required by exposing the socket using a web server like Nginx.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;immortal    - Starts and monitor a service
immortaldir - Directory to scan for services *.yml
immortalctl - Control existing services
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a nutshell, &lt;code&gt;immortal&lt;/code&gt; is a command that runs forever an application or
service.  In most common cases &lt;code&gt;immortal&lt;/code&gt; is called by &lt;code&gt;imortaldir&lt;/code&gt; which
searches for immortal configuration files &lt;a href=&#34;https://immortal.run/post/run.yml&#34;&gt;run.yml&lt;/a&gt; and ideally
starts at boot time in order to persist across reboots.&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/108148.js&#34; id=&#34;asciicast-108148&#34; async&gt;&lt;/script&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>The problem to solve</title>
      <link>https://immortal.run/post/the-problem-to-solve/</link>
      <pubDate>Wed, 20 Jul 2016 21:07:15 +0200</pubDate>
      
      <guid>https://immortal.run/post/the-problem-to-solve/</guid>
      <description>

&lt;h2 id=&#34;a-common-way-to-start-up-services&#34;&gt;A common way to start up services&lt;/h2&gt;

&lt;p&gt;Either you are using macOs, FreeBSD, or any Linux variant the idea is to
simplify how process/services are keep up and running, without need to worry
about special environments or paths.&lt;/p&gt;

&lt;p&gt;A single &lt;a href=&#34;https://immortal.run/post/run.yml&#34;&gt;&lt;code&gt;run.yml&lt;/code&gt;&lt;/a&gt; file should be enough for start and supervise
the services, or used as a template within automation tools like
&lt;a href=&#34;http://saltstack.org&#34;&gt;Saltstack&lt;/a&gt;, &lt;a href=&#34;https://ansible.com&#34;&gt;Ansible&lt;/a&gt;, etc.&lt;/p&gt;

&lt;h2 id=&#34;follow-pid&#34;&gt;Follow PID&lt;/h2&gt;

&lt;p&gt;In some cases it is required to supervise applications that
daemonize by default. Normally this kind of applications create a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Process_identifier#Pidfile&#34;&gt;pidfile&lt;/a&gt; every time
they &lt;a href=&#34;https://en.wikipedia.org/wiki/Fork_(system_call)&#34;&gt;fork&lt;/a&gt;, the one can be
used to follow subsequent forks and avoid creating a race condition between
the supervisor trying to start again the process and the forks created by the
application.&lt;/p&gt;

&lt;p&gt;Example of a race condition while trying to supervise unicorn with runit:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/80371.js&#34; id=&#34;asciicast-80371&#34; async&gt;&lt;/script&gt;
&lt;/div&gt;


&lt;p&gt;In the example given below, after forking (&lt;code&gt;kill -USR2 $PID&lt;/code&gt;), The supervisor in use
&lt;code&gt;runit&lt;/code&gt; in this case, tries to start up again the application, since the
process that was supervising died, but instead enters into loop
because the application still up and running using the same port.&lt;/p&gt;

&lt;h2 id=&#34;logging&#34;&gt;logging&lt;/h2&gt;

&lt;p&gt;When working in distributed &amp;ldquo;cloud&amp;rdquo; environments, centralized logging becomes a
requirement, therefore it is desired to have availability to chose how and where
to log, either to a local file, to a local file and to a remote server or only
remotely either TCP or UDP.&lt;/p&gt;

&lt;p&gt;To achive this, &lt;strong&gt;immortal&lt;/strong&gt; is not only capable to write logs to a defined
file, but is also allows to specify an external logger, by specifying the &lt;code&gt;-l&lt;/code&gt;
and &lt;code&gt;-logger&lt;/code&gt; options example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ immortal -l /tmp/test.log -logger &amp;quot;logger -t test&amp;quot; my-app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case &lt;code&gt;-loger&lt;/code&gt; is going to pass the Stander output/error to the
&lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?logger(1)&#34;&gt;logger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Example logging to a file and to the system syslog using &lt;code&gt;logger&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
    &lt;script type=&#34;text/javascript&#34; src=&#34;https://asciinema.org/a/80376.js&#34; id=&#34;asciicast-80376&#34; async&gt;&lt;/script&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>run.yml</title>
      <link>https://immortal.run/post/run.yml/</link>
      <pubDate>Wed, 06 Jul 2016 20:35:39 +0200</pubDate>
      
      <guid>https://immortal.run/post/run.yml/</guid>
      <description>

&lt;h2 id=&#34;immortal-c-run-yml&#34;&gt;immortal -c run.yml&lt;/h2&gt;

&lt;p&gt;A configuration file for running/logging/supervising:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmd: bundle exec unicorn -c unicorn.rb
cwd: /arena/app-1
env:
    DEBUG: 1
    ENVIRONMENT: production
pid:
    follow: /arena/app-1/unicorn.pid
    parent: /arena/app-1/parent.pid
    child: /arena/app-1/child.pid
log:
    file: /var/log/app-1.log
    age: 86400 # seconds
    num: 7     # int
    size: 1    # MegaBytes
logger: logger -t unicorn
user: www
wait: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the main ideas behind the &lt;code&gt;run.yml&lt;/code&gt; is to eliminate an
operations/devops dependency while deploying.&lt;/p&gt;

&lt;p&gt;The application &amp;ldquo;micro service&amp;rdquo; can be shipped with a &lt;code&gt;run.yml&lt;/code&gt; and when
doing a CI &amp;amp; CD flow, by simple updating the &lt;code&gt;run.yml&lt;/code&gt; file, the &lt;strong&gt;immortal&lt;/strong&gt;
supervisor could stop, restart, pause, resume the service without need to
logging the server and execute does steps.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Nginx to manage the services</title>
      <link>https://immortal.run/post/nginx/</link>
      <pubDate>Fri, 26 Mar 2010 23:14:08 +0200</pubDate>
      
      <guid>https://immortal.run/post/nginx/</guid>
      <description>&lt;p&gt;To expose the services via web &lt;a href=&#34;https://nginx.com&#34;&gt;Nginx&lt;/a&gt; can be used.&lt;/p&gt;

&lt;p&gt;Configuration example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;upstream immortal {
    server unix:/var/run/immortal/sleep/immortal.sock;
}

server {
listen 80 default_server;
server_name _;
location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_http_version 1.1; # for keep-alive
    proxy_pass http://immortal/;
    proxy_redirect off;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the setup, permissions for the socket may need to be changed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ chmod 766 /var/run/immortal/&amp;lt;service name&amp;gt;/immortal.sock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check the service status:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;http://&amp;lt;domain&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To send signals:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;http://&amp;lt;domain&amp;gt;/signal/&amp;lt;signal&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example to stop the service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;http://&amp;lt;domain&amp;gt;/signal/stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start the service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;http://&amp;lt;domain&amp;gt;/signal/start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The responses are in JSON format.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>immortal</title>
      <link>https://immortal.run/post/immortal/</link>
      <pubDate>Thu, 25 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortal/</guid>
      <description>

&lt;p&gt;⭕   &lt;code&gt;immortal&lt;/code&gt; runs a command or script detached from the controlling terminal as a Unix daemon, it will supervise and restart the service if  it has been terminated.  The service can be controlled by querying a Unix socket &amp;ldquo;immortal.sock&amp;rdquo;, this allows to remotely have full control over the service if required by exposing the socket using a web server like Nginx.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;immortal [-v] [-ctl dir] [-d dir] [-e dir] [-f pidfile] [-l logfile] [-logger logger] [-p child_pidfile] [-P supervisor_pidfile] [-u user] command
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;d-dir&#34;&gt;&lt;code&gt;-d dir&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Change to directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; before starting the command&lt;/p&gt;

&lt;h2 id=&#34;e-dir&#34;&gt;&lt;code&gt;-e dir&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Set environment variables specified by files within the &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt;.  For example, if &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; is /tmp/env and contains 3 files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/env
    |--DEBUG  (contains true)
    |--DBHOST (contains 10.0.0.1)
    `--DBPASS (contains secret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An environment var is going to be created for each file, in this case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEBUG=true
DBHOST=10.0.0.1
DBPASS=secret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;f-pidfile&#34;&gt;&lt;code&gt;-f pidfile&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Follow PID in pidfile.&lt;/p&gt;

&lt;p&gt;In  some  cases  it is required to supervise applications that daemonize by default. Normally this kind of applications create a pidfile  every  time  they fork, the one can be used to follow subsequent forks and avoid creating a race condition between the supervisor trying  to  start again the process and the forks created by the application.&lt;/p&gt;

&lt;p&gt;If using &lt;a href=&#34;https://immortal.run/post/immortalctl&#34;&gt;immortalctl&lt;/a&gt; the color yellow on the  Down  column, helps  to  identify  does  process that have been forked and that currently are been supervised by the PID on the &lt;code&gt;&amp;lt;pidfile&amp;gt;&lt;/code&gt;.  When the supervised application forks and creates a  &lt;code&gt;&amp;lt;pidfile&amp;gt;&lt;/code&gt; a log entry (level DAEMON) will be created:&lt;/p&gt;

&lt;p&gt;Watching pid &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt; on file &lt;code&gt;&amp;lt;pidfile&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The  follow  pid option has better performance on Unix/BSD due the kernel event notification mechanism &lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&#34;&gt;kqueue(2)&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;l-logfile&#34;&gt;&lt;code&gt;-l logfile&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Write stdout/stderr to &lt;code&gt;&amp;lt;logfile&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;logger-command&#34;&gt;&lt;code&gt;-logger command&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A command &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to pipe stdout/stderr from stdin.  Besides writing logs locally by using the option -l, they can be sent to a remote host or by processed by another tool, for example to write logs locally and send logs remotely using logger  this  could be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-l /var/log/app.log --logger &amp;quot;logger -h 10.0.0.1 -t app&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-pidfile&#34;&gt;&lt;code&gt;-P pidfile&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Path to write the supervisor pidfile&lt;/p&gt;

&lt;h2 id=&#34;p-pidfile-1&#34;&gt;&lt;code&gt;-p pidfile&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Path to write the child pidfile&lt;/p&gt;

&lt;h2 id=&#34;s-seconds&#34;&gt;&lt;code&gt;-s seconds&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Seconds (int) &lt;code&gt;&amp;lt;seconds&amp;gt;&lt;/code&gt; to wait before starting.&lt;/p&gt;

&lt;h2 id=&#34;u-user&#34;&gt;&lt;code&gt;-u user&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Execute command on behalf &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;v&#34;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Print version&lt;/p&gt;

&lt;h1 id=&#34;the-configuration-file&#34;&gt;The configuration file&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;-c &amp;lt;service name&amp;gt;.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A  configuration  file with valid YAML syntax, when using this option, it will overwrite other options, configuration format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cmd: &amp;lt;command to execute&amp;gt;
cwd: &amp;lt;change workding directory&amp;gt; # option -d
env:                             # option -e
    &amp;lt;key&amp;gt;: &amp;lt;value&amp;gt;
pid:
    follow: &amp;lt;pidfile&amp;gt;            # option -f
    parent: &amp;lt;pidfile&amp;gt;            # option -P
    child: &amp;lt;pidfile&amp;gt;             # option -p
log:
    file: &amp;lt;path&amp;gt;                 # option -l
    age: &amp;lt;int&amp;gt;   # seconds
    num: &amp;lt;int&amp;gt;   # int
    size: &amp;lt;int&amp;gt;  # MegaBytes
logger: &amp;lt;command&amp;gt;                # option -logger
user: &amp;lt;user&amp;gt;                     # option -u
wait: &amp;lt;int&amp;gt;                      # option -s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ctl-var-run-immortal-service&#34;&gt;&lt;code&gt;-ctl /var/run/immortal/&amp;lt;service&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Path where the supervise directory will be created. This directory is unique per
service and is used to manage the service via a Unix socket besides preventing
running multiple times the same service by using a lock.&lt;/p&gt;

&lt;p&gt;A supervise directory containing two files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;lock
immortal.sock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When  calling  immortal  from  the  command line, not by using immortaldir(8) as root, the supervise directory, will be created on  a hidden directory named &amp;ldquo;.immortal&amp;rdquo; within the $HOME of the user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; ~/.immortal/&amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This  helps  to  run  and  supervise the same command multiple times without colliding, useful for testing or for temporary  services that will exit when server reboots.&lt;/p&gt;

&lt;p&gt;To  keep  services  up  and running on boot time, is better to create a configuration file &amp;ldquo;run.yml&amp;rdquo; and use immortaldir(8).&lt;/p&gt;

&lt;h1 id=&#34;environment&#34;&gt;ENVIRONMENT&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;IMMORTAL_SDIR&lt;/code&gt; This environment variable allows to override the default supervise  directory  /var/run/immortal, used also by &lt;a href=&#34;https://immortal.run/post/immortalctl&#34;&gt;immortalctl&lt;/a&gt; and &lt;a href=&#34;https://immortal.run/post/immortaldir&#34;&gt;immortaldir&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>immortalctl</title>
      <link>https://immortal.run/post/immortalctl/</link>
      <pubDate>Wed, 24 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortalctl/</guid>
      <description></description>
    </item>
    
    <item>
      <title>immortaldir</title>
      <link>https://immortal.run/post/immortaldir/</link>
      <pubDate>Tue, 23 Mar 2010 23:34:54 +0200</pubDate>
      
      <guid>https://immortal.run/post/immortaldir/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>